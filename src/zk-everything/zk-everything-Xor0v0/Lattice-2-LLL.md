# LLL算法
> 作者简介：Xor0v0，硕士在读，零知识证明小白，目前在做一些circom开发和zk审计，密码学爱好者，打过一些web2/3 CTF，最近对zkHACK产生兴趣。欢迎各位大佬一起交流学习。

LLL 算法于 1982 年由三位 L 开头的外国人设计（因此得名），是一种解决 SVP 的近似算法。

LLL 算法的近似率为 $(\frac{2}{\sqrt{3}})^n$ ，其中 n 是格的维度。在大多数应用中，n都是一个常数，因此近似率是确定的。

1801年 Guass 给出一种解决二维 SVP 的算法， LLL 算法可以看作是Gauss的算法对高维的推广。

LLL 的用途：

1. 分解整数或者有理数上的多项式。比如分解 $x^2-1$ 为 $(x+1)$ 和 $(x-1)$ 。

2. 求一个给定代数的最小多项式足够好的 approximation。例如，给定 $1.414213$ 输出 $x^2−2=0$ ，给定 $0.645751$ 输出 $x^2+4x−3=0$ 。

3. 求解整数关系，对于一组实数 $x_1, \dots,x_n$ ，如果存在一组非全零整数 $a_1,\dots,a_n$ 使得 $a_1x_1+\dots+a_nx_n=0$ 成立，则称为这组实数具有整数关系。比如，给定 $\arctan(1),\arctan(1/5),\arctan(1/239)$ ，可以证明下列整数关系存在：

$$
\arctan(1)-4\arctan(1/5)+\arctan(1/239)=0
$$

这个等式被称为 $Machin$ 公式。

4. 整数规划问题。这是一个著名的 NP 问题，使用LLL，可以在多项式时间解决固定数量变量的整数规划。

5. 最近向量问题(CVP)，以及其他格问题。

6. 密码分析中的各种应用（即破坏密码协议）。 例如，对基于背包的密码系统的许多攻击。 对RSA的一些特殊情况也有一些攻击，如低公共指数攻击(low public exponent attack)。此外，对DSA系统中求解 HNP 问题也是很好的攻击应用。

下面从三个方面介绍 LLL 算法：

1. 定义一个 LLL 规约基 (reduced basis)，
2. 提出一种算法来寻找这样的规约基，
3. 分析其运行时间。

## 1. Reduced Basis

首先回顾施密特正交化的定义：

定义 1: 给定 n 个线性无关向量 $\pmb{b_1}, \pmb{b_2}, \dots,\pmb{b_n}\in\mathbb{R}^n$ ，其施密特正交化的定义为：

$$
\tilde{\pmb{b}}_i=\pmb{b}_i-\sum_{j=1}^{i-1}{\mu_{i.j}},where \mu_{i,j}={\frac{(\pmb{b_i,\tilde{b}_j})}{\pmb{(\tilde{b}_j,\tilde{b}_j)}}}
$$

定义 2: 如果下列情况成立，则格基 $B= \pmb{b_1}, \pmb{b_2}, \dots,\pmb{b_n}\in\mathbb{R}^n$ 是一个 $\gamma-LLL$ 规约基: 

1. $\forall 1\le i\le n, j\lt i,|\mu_{i,j}|\le1/2$ .
2. $\forall 1\le i\lt n, \gamma||\pmb{\tilde{b}}_i||^2\le ||\mu_{i+1,i}{\pmb{\tilde{b}_i+\tilde{b}_{i+1}}}||^2$ .

Remark 1：把一个基转换为规约基总是有可能的，实际上 LLL 算法就是在做这件事。

Remark 2 ：考虑 $\gamma=3/4$ 的清醒是很有用的，在 LLL 算法中， $1/4\lt\gamma\lt1$ .

Remark 3 ：定义 2中的第二个条件可以等价变化为：

$$
\gamma||\pmb{\tilde{b}}_i||^2\le ||\mu_{i+1,i}{\pmb{\tilde{b}_i+\tilde{b}_{i+1}}}||^2=\mu_{i+1,i}^2||\pmb{\tilde{b}_i}||^2+||\pmb{\tilde{b}_{i+1}}||^2
$$

稍微变换之后，可知：第二个 property 可以解释为: $\pmb{\tilde{b}_{i+1}}$ 不会比 $\pmb{\tilde{b}_{i}}$ 短很多。

具体的，我们考虑经过施密特正交化得到的格基矩阵为：

$$
\begin{pmatrix}
||\tilde{\pmb{b}}_1||&*&\dots&*\\
0&||\tilde{\pmb{b}}_2||&\dots&*\\
\dots&\dots&\dots&\dots\\
0&\dots&0&||\tilde{\pmb{b}}_n||
\end{pmatrix}
$$

【在线性代数中，正交基可以表示为基向量范数的上三角形式，这是由正交基的性质和**格拉姆-施密特正交化过程的结果**所决定的。】

其中列 i 显示了在这个正交基中 $b_i$ 的坐标。 定义LLL约减基中的第一个条件保证：任何非对角元素的绝对值，最多是同一行对角线元素值的一半。 这可以写成：

$$
\begin{pmatrix}
||\tilde{\pmb{b}}_1||&\le||\tilde{\pmb{b}}_1||&\dots&\le||\tilde{\pmb{b}}_1||\\
0&||\tilde{\pmb{b}}_2||&\dots&\le||\tilde{\pmb{b}}_2||\\
\dots&\dots&\dots&\dots\\
0&\dots&0&||\tilde{\pmb{b}}_n||
\end{pmatrix}
$$

第二个条件要求这个矩阵的第二列几乎和它的第一列一样长。

LLL 规约基的一个重要特性是它的第一个向量相对较短，如下一个 **claim** 所示。

Claim 1：假设  $\pmb{b_1}, \pmb{b_2}, \dots,\pmb{b_n}\in\mathbb{R}^n$ 是一个 $\gamma-LLL$ 规约基，则有：

$$
||\pmb{b}_1||\le(\frac{2}{\sqrt{4\gamma-1}})^{n-1}\lambda_1(\mathcal{L})
$$

Remark 4: 如果 $\gamma=3/4$ 则有：

$$
||\pmb{b}_1||\le2^{\frac{n-1}{2}}\lambda_1{(\mathcal{L})}
$$

## 2. LLL Algorithm

```
INPUT:Lattice basis b1, . . . , bn ∈ Zn
OUTPUT: gamma-LLL-reduced basis for L(B)
	Start: compute Gram-Schmidt basis
	Reduction Step: 
	for i=2 to n do:
		for j=i-1 to 1 do:
			bi <- bi − c_ij * bj
	Swap Step:
		如果存在i使得第二个条件反向成立，then
			bi <-> b_{i+1}
			goto Start
Output: bi, ..., bn
```

首先注意到， `Swap` 步骤中如果不满足第二个条件，直接终止。

其次，在 `Reduction` 步骤中，正交基无需改变（重新计算）。因为只需要从后往前进行列变换即可【注意内循环】。

具体的证明可以看原文。

## 3. Complexity Analyze

分析包括两个步骤。 首先，我们 bound 了迭代次数。 其次，我们 bound 了单个迭代的运行时间。

可以证明：算法的总体运行时间是关于输入规模的多项式。 输入规模的 rough下界由 $M=\max\{n,\log(max_i|||b_i|\}$ 给出。（因为 n 个向量中的每一个都需要至少一位来表示，范数为 r 的向量需要至少 $\log r$ 位来表示)。 

定理 1: 迭代次数是关于 M 的多项式。

定义 5: 给定格基 B，那么 B 的 potential 是它的施密特正交化后的基的范数乘积。

整个证明过程没看懂，下次如果看懂了再来补充。有兴趣的可以去看原文，证明过程使用到了这个格基的 Potencial。

## 4. Solve a HNP with Lattice in Paradigm CTF 2023

既然学了 LLL 算法，可以初步看看它有什么神奇的魔力。

题目地址： https://github.com/paradigmxyz/paradigm-ctf-2023/tree/main/oven

```python
#!/usr/bin/env python3
from Crypto.Util.number import *
import random
import os
import hashlib

FLAG = os.getenv("FLAG", "PCTF{flag}").encode("utf8")
FLAG = bytes_to_long(FLAG[5:-1])
assert FLAG.bit_length() < 384

BITS = 1024


def xor(a, b):
    return bytes([i ^ j for i, j in zip(a, b)])


# This doesn't really matter right???
def custom_hash(n):
    state = b"\x00" * 16
    for i in range(len(n) // 16):
        state = xor(state, n[i : i + 16])

    for _ in range(5):
        state = hashlib.md5(state).digest()
        state = hashlib.sha1(state).digest()
        state = hashlib.sha256(state).digest()
        state = hashlib.sha512(state).digest() + hashlib.sha256(state).digest()

    value = bytes_to_long(state)

    return value


def fiat_shamir():
    p = getPrime(BITS)
    g = 2
    y = pow(g, FLAG, p)

    v = random.randint(2, 2**512)

    t = pow(g, v, p)
    c = custom_hash(long_to_bytes(g) + long_to_bytes(y) + long_to_bytes(t))
    r = (v - c * FLAG) % (p - 1)

    assert t == (pow(g, r, p) * pow(y, c, p)) % p

    return (t, r), (p, g, y)


while True:
    resp = input("[1] Get a random signature\n[2] Exit\nChoice: ")
    if "1" in resp:
        print()
        (t, r), (p, g, y) = fiat_shamir()
        print(f"t = {t}\nr = {r}")
        print()
        print(f"p = {p}\ng = {g}\ny = {y}")
        print()
    elif "2" in resp:
        print("Bye!")
        exit()
```

每一轮的 t, r, p, g, y 都告诉我们了，要求 flag。

注意到 `fiat_shamir` 函数的 $r=(v-c*FLAG)\mod(p-1)$ ，还有后面那个断言。

可以很容易想到 [HNP 问题](https://zhuanlan.zhihu.com/p/581146119#:~:text=%E7%9A%84%EF%BC%8C%E6%8D%A2%E6%B1%A4%E4%B8%8D%E6%8D%A2%E8%8D%AF%E5%95%8A%EF%BC%81-,HNP,-%EF%BC%9A%E9%9A%90%E8%97%8F%E6%95%B0%E5%AD%97%E9%97%AE%E9%A2%98)，HNP(Hidden Number Problem)，这个问题由Dan Boneh于1986年[提出](https://crypto.stanford.edu/~dabo/pubs/abstracts/dhmsb.html)。 另一位大佬，使用Lattice攻破了DSA的HNP问题，参考[论文](https://link.springer.com/chapter/10.1007/978-3-0348-8295-8_23) 。

对于这道题，我们简单分析一下：

> 首先 v 和 FLAG 都是未知的，其他都泄漏出来的（c可以根据那个自定义hash函数算出来）。
>
> 而题目又泄漏了 FLAG 的长度小于 384

我们可以使用论文的方式构造格矩阵，然后使用LLL算法在多项式时间内找到一个解向量，FLAG值就在这个向量里。

至于如何构造格，这涉及到 Babai 最近平面算法细节，用于解决 CVP 问题。这个我在下一篇文章会详细在讲解，届时大家就会知道这道题原理。（下一篇文章我也会用小章节对这道题原理进行解释）

下面贴出EXP（需要使用 sage-python）。

```python
from Crypto.Util.number import *

BITS = 1024
def custom_hash(n):
    state = b"\x00" * 16
    for i in range(len(n) // 16):
        state = xor(state, n[i : i + 16])

    for _ in range(5):
        state = hashlib.md5(state).digest()
        state = hashlib.sha1(state).digest()
        state = hashlib.sha256(state).digest()
        state = hashlib.sha512(state).digest() + hashlib.sha256(state).digest()

    value = bytes_to_long(state)

    return value



g = 2
# p = remote("oven.challenges.paradigm.xyz", 1337)
# # v = (c * flag - r) % (p-1)
# t = 5
# while t > 0:
#     p.sendafter(b'Choice: ', b'1')
#     a = p.recvuntil(b't =')
#     t = int(p.recvuntil(b'\n', drop=True).decode())
#     a = p.recvuntil(b'r = ')
#     r = int(p.recvuntil(b'\n', drop=True))
#     a = p.recvuntil(b'p = ')
#     p = int(p.recvuntil(b'\n', drop=True))
#     a = p.recvuntil(b'g = ')
#     g = int(p.recvuntil(b'\n', drop=True))
#     a = p.recvuntil(b'y = ')
#     y = int(p.recvuntil(b'\n', drop=True))
#     C = [0]
#     R = [0]
#     C.append(custom_hash(long_to_bytes(g) + long_to_bytes(y) + long_to_bytes(t)))
#     R.append(r)
#     t -= 1
t, r, p, y = [0] * 5 , [0] * 5, [0] * 5, [0] * 5
t[0] = 77203516334611379622052884088061339907818193440975523438325956774518601252973654146535129884349539724229562993644509567711307331031087898034347437358013492439542334272757402388064753335866738748958633246857368058563448192261648964749496750146315450540579452655462143813022469489449782882109182150142188348915
r[0] = 116220687218790216091346463439819557695309512176282372943331613053767874084111192169275378671194392846117055362014832383093646731110903547936340541580638231783076185430700045752799252596702505486227877656990705143138976716233681199944248043915239678537679463030334043412573684866623347545004904612417007327217
p[0] = 120199526136097511651530856988060166616679725925744594620901500430819054365226668422844742178771316732438545888088210068701212930988908604238682153307940417480817112540019257024703372145496636861112290091005527647339212358159274475077103689996624113678044891963676612334769162753166782062809526104431258739517
y[0] = 113120257926989954605307518460817169666869094087243249194566086300779837721481071230484420555504633839932263287201776945834030877253212748181186108770595676114564711457140738635967367144272960236148346810327070118837330648022676963528356209004524421455348155068637534190736042536625876773755044593606026293621

t[1] = 41870694301936832255997763505666386906032641226067235004722895066736677752643938706563985367861597477876358530714740119529535551345537670465925209944735777464498665457291484991606280197421907773811941255514802343059520166452091324746732103649911088736843268706303230993742963740287185306251052313964374872878
r[1] = 12006544761341621619143613218949584457040818188588282396732221317912350712975184254483346994199077889478797005980544401923303196850089656891130607887735812677733676744158835380723268515678724429529904080449565289532493612340517128773817940478185157405384294596975266141639161297056291778600404606940053392754
p[1] = 144976418899543143198454834264506179459614866666312385853989423989111679486891620786778481577472101748200328617607483446519049911023390427543308348494008425688855119367843479385647790189753163858970088620586505610840306212549243890107847423807556106192434514110736278569625282073529181653986405771513594134987
y[1] = 115167386542298909971939136044531943159982371048242494889745996527683250097061534781946312891817534916886291355204474301571862159042350976750824212346443402817552375266223638549309886922860921533308382456941718605370216473858986207878047206914813902333192745354148659984602740644345120423788258359941122554440

t[2] = 87583398382601313926735945950364130572816213989909728661491063393166341618362097121819023078210854251839415225428442334046015192711593400640556960974162962105001700930842075200923675422451049033428478754684678493480503204152097382431043129863362081278994409790477935899740897031656629902670114002180266872266
r[2] = 102934065416140965550261549535302192284582871606378190882003659362832329206469482926448881926648454509204767788745574969527319053553977362277660636749471357711849435384231867496681956889560719871615670691536165668156919285052370364456208767031233707532145718791283351837119192545712583721765194876277656314501
p[2] = 148550372281025138704553107737801144273208690400094973764375300381759456124146034135721454543469874579375457504983315183916592877731262163382903701414433532933994780412246010260680217160047355295328211970740422311833479381733781665221952277321615395653804905426059251551309558237245071919868160643681548296643
y[2] = 140198181685722792932050421128846820269664976993249152496309458637445728558822919357043381776927596511506695168631000635135982453895569864162220417018046902591680662347467431250148020323787868422484882819040766008876291088199475630773774170507517261352416744218315033367149608507518388781373699289693595499544

t[3] = 84522638373733120165414722745998118253921972157096808350845007682435315263298662575419222718886673005893479175168776223733676055437884841441137160382376309254755315837431162807596684224207280410300146602535834124511928134257346386899792746556440632650091111389088724071203568000188430042064500145669267026805
r[3] = 18194520459417696159241442307764982202112775710358263541565999857475375951014745782344717997571109484480490257320469370655821185611675102820226656623202547826938945675557174044055104570245311622199906030109190773202049867448625926033119474090713737736579814394048548084259404911639299693897437586858871472420
p[3] = 103592121279236435866010649601463899558315038309765463516665073413464806869884601040096405354399740035138081866812671953467986059509640644754973422603659825874707510675199511411437487386173194105311776020901134014680450244319046258962912483163270496586124101308664731409973532774829535980996775736651508448187
y[3] = 14795900031448786771559087453548388682769488350377145090464794455644462363656204398769939585810191748312766604278524960492756615478207654208905403516432929452543777164921589629460212814049479518397521600744701463005793924336243982001830978693343863219168046923285752069874971698699611717027496799587761203398

t[4] = 137831113158715069584199906447354477289195801883097400523644937444161950367086728510388467524069532778534704803863447302183665431906725284462350375136938902398115607751357373983532375894744842377064414618294084293556345908653608825144019924463160996581138334794345538184522294219836499291245958693984828705682
r[4] = 3997479613798995088324714249284251759517244566415954213469045459939167234231804927756343425727094668124791771030709612850292188541459113635924389128360073088700133564458353848851347410209029075825332791761713207287049093830610503236793718093861017715600469118069736180200062407135030791797264421955154056362
p[4] = 138872772594377036406739890812487312629206229880091799534033353266413752242871671695030657233827552372256865312690361457743622953282647882392520626248323032818493170021525093526571072858177665184977821075559705014261503440906447428819858532553737164369106583570452357928945241596555378143414688075425304805029
y[4] = 26528279589882510502916765470759890048295757018825608100058824483278181810141819962488106009190787416456734047325734614749916264837565765983213768504298640943869226245566784325431289650031372028094050672872660334951958006567067601586551947694563576820491204290496425885685101313332190690230962899252834723225

i = 0
C = [0]
R = [0]
while i < 5:
    C.append(custom_hash(long_to_bytes(g) + long_to_bytes(y[i]) + long_to_bytes(t[i])))
    R.append(r[i])
    i += 1
    
C = C[1:]
R = R[1:]
# print(C)
# print(R)

M = matrix(ZZ, 5, 5)
for i in range(3):
    M[i, i] = p[i]
    M[3, i] = C[i]
    M[4, i] = R[i]
    M[i, 3] = M[i, 4] = 0
M[3, 3] =  1
M[4, 4] = 2^64
M[3, 4]= 0
    
v = M.LLL()[0]
print(v)
flag = v[3] % p[3]
print(long_to_bytes(flag))
```

